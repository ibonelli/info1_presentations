<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Info1 - Linux</title>

		<meta name="description" content="Info1 - Programación">
		<meta name="author" content="Ignacio J. Bonelli">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- For full screen images -->
		<!--     from - https://github.com/regisb/reveal.js-fullscreen-img -->
		<link rel="stylesheet" href="css/fullscreen-img.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

<section>
<section>
<h1>Estructuras</h1>
</section><section>
<h2>Datos compuestos</h2>
<ul>
<li>Ya vimos como agrupamos datos del mismo tipo. Tenemos arreglos (vectores y matrices) o strings (cadenas de caracteres).</li>
<li>¿Como agrupamos datos de distinto tipo?<ul>
<li>Palabras clave: struct y union</li>
</ul>
</li>
<li>¿Por que podemos querer hacerlo?<ul>
<li>Ejemplo: Entidad alumno tiene distintos datos como nombre, apellido, edad, legajo, etc...</li>
<li>Para hacer que los programas sean mas simples, sencillos, ordenados y naturales.</li>
</ul>
</li>
</ul>
</section><section>
<h2>El tipo "struct"</h2>
<ul>
<li>La estructura ("struct") es un conjunto de una o mas variables, agrupadas u organizadas bajo un único nombre, cuyos miembros pueden ser de tipos diferentes</li>
<li>La estructura la define el programador y es un nuevo tipo de dato</li>
<li>Declaración:</li>
</ul>
<p>struct identificador-nombre {
    tipo1 componente1;
    tipo2 componente2;
    ...
    tipoN componenteN;
} lista_variables;</p>
</section><section>
<h2>Ejemplo: estructura para puntos en la pantalla</h2>
<p>struct point {
    int x;
    int y;
};</p>
<p>struct point punto;</p>
<p>/<em> var tipo point </em>/
struct point puntoMax = {640, 480};</p>
<p>punto.x = 300;      /<em> acceso al elemento con </em>/
punto.y = 200;      /<em> sintaxis operador punto </em>/</p>
</section><section>
<h2>Estructura: Acceso a campos</h2>
<ul>
<li>Accediendo como variable:<ul>
<li>Uso el punto (.)</li>
</ul>
</li>
<li>
<p>punto.x = 300;</p>
</li>
<li>
<p>Accediendo como puntero:</p>
<ul>
<li>Uso la flecha (-&gt;)</li>
</ul>
</li>
<li>struct point <em>pA,</em>pB;</li>
<li>PA = &A;</li>
<li>pB -&gt; x = pA -&gt; x;</li>
</ul>
</section><section>
<h2>Ejemplo: estructura para puntos en la pantalla</h2>
<ul>
<li>Función que trabaja con estructuras (prototipo)</li>
</ul>
<p>struct point sumaPuntos (struct point p1,
                         struct point p2);</p>
<p>struct point sumaPuntos (struct point p1,
                         struct point p2) {
    p1.x += p2.x;
    p1.y += p2.y;
    return p1;
}</p>
</section><section>
<h2>Formas de operar con struct</h2>
<ul>
<li>Uso de un campo
estructura.componente
a2.nota1 = 7.5;</li>
<li>Asignación de una estructura a otra (depende del compilador, sino copiar campo x campo)
a2 = a1;</li>
<li>Declaración y asignación
struct Alumnos a = {"Celeste Carballo",
                                "7654321",
                                6.0, 5.5, 5.0, 5.5};</li>
<li>Función que retorna una estructura
struct Alumnos nuevoAlumno(char nombre[ ]) { ...</li>
<li>Función que recibe como argumento una estructura
void calculaNota(struct Alumnos a1) { ...</li>
</ul>
</section><section>
<h2>Estructuras anidadas</h2>
<p>struct fecha {
    int dia, mes, anio;
};</p>
<p>struct persona {
    char nombre[20];
    char apellido[20];
    struct fecha nacimiento;
    unsigned long telefono;
};
struct persona amigo[30];   /<em> array </em>/
amigo[15].nacimiento.anio = 1982;</p>
</section><section>
<h2>typedef</h2>
<ul>
<li>Es una palabra clave que permite definir nuevos tipo de datos:</li>
</ul>
<p>struct point {
    int x;
    int y;
};</p>
<p>typedef struct point punto;
punto A,B;
A.x =1;</p>
</section><section>
<h2>Union</h2>
<ul>
<li>Las uniones son agrupaciones de datos cuyos miembros comparten la misma memoria (es decir, se solapan)</li>
<li>El tamaño total ocupado es el del miembro mas grande
union equivalencia {
    int i;
    char c;
};</li>
</ul>
<p>union equivalencia x;</p>
<p>x.i = 5;
x.c = 'A';</p>
<p>Nota: Ambos están en la misma posición de memoria. Por lo tanto la 'A' sobre escribe al 5.</p>
</section><section>
<h2>Campos de bits</h2>
<ul>
<li>Son estructuras (struct) pero de tamaño menor a 1 byte (char).</li>
<li>Se puede definir de cada campo que tamaño en bits tiene.</li>
<li>Esto le permite a C un acceso a datos a nivel de bit agregandole flexibilidad y elegancia.</li>
<li>Las otras técnicas de acceso son mucho menos claras (mascaras y operadores a nivel de bit).</li>
</ul>
</section><section>
<h2>Campos de bits</h2>
<p>struct alfa {
   unsigned char c:1;
   unsigned char a:2;
   unsigned char b:3;
};</p>
<p>struct beta {
   unsigned int d:5;
   unsigned int e:9;
   unsigned int f:2;
};</p>
</section><section>
<h2>Campo de Bits y Uniones</h2>
<ul>
<li>
<p>Uniones - Código</p>
<ul>
<li>campos-de-bit.c : Ejemplo trivial de uniones y campos de Bits</li>
</ul>
</li>
<li>
<p>Uniones - Ejercicio</p>
<ul>
<li>Realizar un programa que devuelva el primer carácter (inicial) de un string/nombre usando uniones.</li>
<li>Realizar un programa que tome un número en punto flotante y devuelva sus partes usando uniones y campos de bit.</li>
</ul>
</li>
</ul>
</section><section>
<h2>Enumeraciones</h2>
<ul>
<li>Un tipo de datos enumerado es una manera de asociar nombres a números, y por consiguiente de ofrecer más significado a alguien que lea el código.</li>
<li>La palabra reservada enum (de C) enumera automáticamente cualquier lista de identificadores que se le pase, asignándoles valores de 0, 1, 2, etc (enteros).<ul>
<li>O sea, permiten crear conjuntos de constantes nombradas</li>
<li>Si no son forzados el primer nombre del enum tiene valor 0, el siguiente 1 y así sucesivamente</li>
</ul>
</li>
<li>Se pueden declarar variables enum (que se representan siempre como valores enteros).</li>
<li>La declaración de un enum se parece a la declaración de un struct, tiene la misma sintaxis.</li>
</ul>
</section><section>
<h2>Enumeraciones</h2>
<ul>
<li>
<p>enum {lista_de_identificadores};</p>
<ul>
<li>enum nombre_de_tipo {lista_de_identificadores};</li>
<li>typedef enum {lista_de_identificadores} nombre_enumeracion;</li>
</ul>
</li>
<li>
<p>typedef enum {FALSE = 0, TRUE = 1} boolean;</p>
</li>
</ul>
</section><section>
<h2>Enumeraciones</h2>
<ul>
<li>Enumeraciones - Ejemplos<ul>
<li>enum1.c y enum2.c : Ejemplos sencillos</li>
</ul>
</li>
<li>Enumeraciones - Ejercicios<ul>
<li>Construir un programa que dados los colores de una resistencia nos de su valor en ohm.</li>
<li>Construir un programa que muestre un menú y e indique la opción seleccionada, empleando una enumeración y una lista de cadenas.</li>
</ul>
</li>
</ul>
<p>enum3_ejemplo.c</p>
</section>

<section>
##Otros temas##
* Memoria dinámica
* Intro listas
</section>

</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				// Cambio el tamaño del slide
				width: '80%',

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
					// For full screen images, from:
					//		https://github.com/regisb/reveal.js-fullscreen-img
					{ src: 'lib/js/fullscreen-img.js' }
				]
			});

		</script>

	</body>
</html>
