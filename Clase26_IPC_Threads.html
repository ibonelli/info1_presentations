<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Info1 - IPC & Threads</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Ignacio Bonelli">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

<section>
	<h1>IPCs, Procesos Zombies y Threads</h1>
	<p>
		<small>Ing. Ignacio Javier Bonelli</small>
	</p>
</section>

<section>
<section>
<h2>IPCs</h2>
<h3>Inter Process Communication</h3>
<br />
<p>O como comunicar programas o procesos dentro de una misma máquina</p>
</section>

<section>
<h2>Tipos de IPCs</h2>
<br />
<ul>
	<li>Signals</li>
	<li>Semaphores</li>
	<li>Shared Memory</li>
	<li>Transmisión de datos:
		<ul>
			<li>Pipes</li>
			<li>Message Queues</li>
			<li>Sockets</li>
		</ul>
	</li>
</ul>
</section>

<section>
<h2>Versiones y estándards</h2>
<br />
<ul>
	<li><b>POSIX</b> (Portable Operating System Interface junto con la X que viene de UNIX) : Identifica a la API y es una norma escrita por la IEEE. Define una interfaz estándar del sistema operativo y el entorno.</li>
	<li><b>BSD</b> (Berkeley Software Distribution) : Esta linea de Unix con código abierto ha generado muchos decendientes como FreeBSD, OpenBSD, NetBSD y DragonFly BSD.</li>
	<li><b>UNIX System V</b> : Fue la versión más popular de Unix comercial inicialmente desarrollada por AT&amp;T</li>
</ul>
<br/><br/>
<a style="font-size: 75%;" href="files/clase26/Unix_history-simple.svg">Gráfico con la historia de Unix y sus versiones</a>
</section>

<section>
<h2>IPCs</h2>
<ul>
	<li><a href="http://beej.us/guide/bgipc/">Manual Beej</a> y <a href="https://users.cs.cf.ac.uk/Dave.Marshall/C/">Página de Dave Marshall</a></li>
	<li>Semaphore: <a href="https://beej.us/guide/bgipc/html/multi/semaphores.html">Beej</a>, <a href="https://users.cs.cf.ac.uk/Dave.Marshall/C/node26.html#SECTION002600000000000000000">DaveM</a> y <a href="https://en.wikipedia.org/wiki/Semaphore_%28programming%29">Wikipedia</a></li>
	<li><a href="https://users.cs.cf.ac.uk/Dave.Marshall/C/node24.html#SECTION002400000000000000000">Signals</a>, <a href="https://users.cs.cf.ac.uk/Dave.Marshall/C/node23.html#SECTION002300000000000000000">Pipes</a>, <a href="https://users.cs.cf.ac.uk/Dave.Marshall/C/node27.html#SECTION002700000000000000000">Shared Memory</a> y <a href="https://users.cs.cf.ac.uk/Dave.Marshall/C/node25.html#SECTION002500000000000000000">Msg Queue</a></li>
	<li>Lock: <a href="https://en.wikipedia.org/wiki/Lock_(computer_science)">Wikipedia</a></li>
	<li>Monitor: <a href="https://en.wikipedia.org/wiki/Monitor_(synchronization)">Wikipedia</a></li>
</ul>
</section>
</section>

<section>
<section>
<h2>IPCs - Signals (I)</h2>
<br/>
<p>Macros definidas en el archivo header &lt;signal.h&gt; <br/>para las señales mas comunes:</p>
<pre><code data-trim style="font-size: 18px; margin-top: 20px;" class="bash">
man 7 signal

Signal     Value     Action   Comment
----------------------------------------------------------------------
SIGHUP        1       Term    Hangup detected on controlling terminal
                              or death of controlling process
SIGINT        2       Term    Interrupt from keyboard
SIGQUIT       3       Core    Quit from keyboard
SIGILL        4       Core    Illegal Instruction
SIGABRT       6       Core    Abort signal from abort(3)
SIGFPE        8       Core    Floating-point exception
SIGKILL       9       Term    Kill signal
...
SIGALRM      14       Term    Timer signal from alarm(2)
SIGTERM      15       Term    Termination signal
</code></pre>
</section>

<section>
<h2>IPCs - Signals (II)</h2>
<br/>
<pre><code data-trim style="font-size: 18px; margin-top: 20px;" class="bash">
SIGUSR1   30,10,16    Term    User-defined signal 1
SIGUSR2   31,12,17    Term    User-defined signal 2
SIGCHLD   20,17,18    Ign     Child stopped or terminated
SIGCONT   19,18,25    Cont    Continue if stopped
SIGSTOP   17,19,23    Stop    Stop process
...

SIGALRM 14 /* alarm clock */
SIGCONT 19 /* continue a stopped process */
SIGCHLD 20 /* to parent on child stop or exit */

POSIX.1-1990, POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD, ...

Signals can be numbered from 0 to 31.
</code></pre>
</section>

<section>
<h2>IPCs - Signals</h2>
<h3>Ejemplo</h3>
<br/>
<pre><code data-trim style="font-size: 18px; margin-top: 20px;" class="cpp">
#include &lt;signal.h&gt;
#include &lt;sys/types.h&gt;

sighandler_t signal(int signum, sighandler_t handler);

int kill(pid_t pid, int sig);
</code></pre>
<br/>
<p style="text-align: left; margin-left: 300px;">Código:</p>
<ul>
	<li><a href="./files/clase26/signals.c">signals.c</a></li>
	<li><a href="./files/clase26/sig_talk.c">sig_talk.c</a></li>
</ul>
</section>
</section>

<section>
<section>
<h2>IPCs : Message Queue</h2>
<h3>Ejemplo</h3>
<br/>
<p>Ejemplo sencillo IPC:</p>
<p><a href="http://beej.us/guide/bgipc/">Mensajes por Beej</a>: <a href="files/clase26/beej_kirk.c">kirk.c</a> y <a href="files/clase26/beej_spock.c">spock.c</a></p>
<p>El comando "ipcs" lista los IPC abiertos, si lo corremos mientras los procesos kirk/spock corren reporta sobre la actividad.</p>
</section>
</section>

<section>
<section>
<h2>Shared Memory</h2>
<br />
<p style="text-align: left; margin-left: 30px;">Dos opciones:</p>
<ul>
	<li>La forma clásica (System V):
		<ul>
			<li style="font-size: 90%;"><span style="font-family: monospace;">shmget()</span>: Allocates shared memory segment</li>
			<li style="font-size: 90%;"><span style="font-family: monospace;">shmctl()</span>: Shared memory control</li>
			<li style="font-size: 90%;"><span style="font-family: monospace;">shmat()</span>: Shared memory Attach operation</li>
			<li style="font-size: 90%;"><span style="font-family: monospace;">shmdt()</span>: Shared memory Detach operation</li>
		</ul>
	</li>
	<li>La forma mas moderna: <span style="font-size: 90%; font-family: monospace;">mmap()/munmap()</span></li>
	<p style="margin-left: 30px;">map or unmap files or devices into memory</p>
	<a style="margin-left: 100px;" href="files/clase26/shared_memory2.c">shared_memory2.c</a>
</ul>
</section>
</section>

<section>
<p>Ver ejemplo TCP/IP con fork : <a href="files/clase21/tcp-servidor.c">Servidor</a> y <a href="files/clase21/tcp-cliente.c">Cliente</a></p>
<br/>
<p>¿Que pasa si corremos 3 hijos y el padre <br/>cuando terminan los hijos?</p>
<br/>
<p>Ver con:</p>
<pre><code data-trim style="font-size: 18px; margin-top: 20px;" class="bash">
watch -n 1 "ps elf | grep tcp | grep -v grep"
</pre></code>
<br/>
<p>tcp/ip + fork (sin wait) => ¡hijos zombies!</p>
</section>

<section>
<a href="files/clase26/terminator_zombies.png"><img src="files/clase26/terminator_zombies.png"/></a>
</section>

<section>
<h2>Zombies</h2>
<br />
<p>Proceso Zombie : Muere el hijo y el padre no se entera.</p>
<a href="files/clase26/zombie1.c">zombie1.c</a>
<br /><br />
<p style="text-align: left;">Formas de evitarlo:</p>
<ol>
	<li>Usando la función de wait() en el padre.</li>
	<a style="margin-left: 100px;" href="files/clase26/zombie2.c">zombie2.c</a>
	<li>Ignorando la señal SIGCHLD en el padre.</li>
	<a style="margin-left: 100px;" href="files/clase26/zombie3.c">zombie3.c</a>
	<li>Usamos un signal handler.</li>
	<a style="margin-left: 100px;" href="files/clase26/zombie4.c">zombie4.c</a>
</ol>
</section>
</section>

<section>
<section>
<h2>Threads</h2>
<br />
<p>Corriendo procesos en paralelo que son mas livianos y flexibles que los creados por fork.</p>
</section>

<section>
<h3>Fork</h3>
<p>fork nos da un nuevo proceso que es una copia del actual. Tiene una "copia" de la memoria original. A medida que los nuevos procesos avanzan los valores de cada uno en memoria cambian, pero el ejecutable es el mismo. Los procesos/tareas no comparten memoria, la única forma de compartir algo es usar IPCs.</p>
<br />
<h3>Threads</h3>
<p>Un proceso puede tener multiples threads, cada una ejecutandose en paralelo dentro del mismo contexto (memoria). Todos los recursos son compartidos, usan la misma memoria. Se deben usar mecanismos de lock y sincronización para evitar problemas.</p>
</section>

<section>
<h2>Threads</h2>
<br />
<img src="files/clase26/threads.jpg"/>
</section>

<section>
<h2>Threads</h2>
<pre><code>
#include &lt;pthread.h&gt;

/* ¿Son tid1 y tid2 el mismo thread? */
int pthread_equal(pthread_t tid1, pthread_t tid2);

/* Retornar el pthread ID actual */
pthread_t pthread_self(void);

/* Creando un thread */
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, 
                   void *(*start_routine) (void *), void *arg);
</code></pre>
<ul style="font-size: 75%;">pthread_create():
	<li>En thread nos devolveran el ID del thread creado</li>
	<li>Atributos que puede tener thread el (ya sea prioridad u otros). Puede ser NULL</li>
	<li>Puntero a la función que debe ejecutar el thread</li>
	<li>Parametros de la funcion que ejecutar el thread. Si toma void, puede ser NULL</li>
</ul>
</section>

<section>
<h2>Un ejemplo:</h2>
<h3><a href="files/clase26/threads.c">threads.c</a></h3>
<br />
<p>Para leer mas...</p>
<ul>
	<li><a href="http://www2.electron.frba.utn.edu.ar/~mdoallo/presentaciones.save.2010/clase-20100916-threads">Threads en Linux</a> (por Ing. Marcelo Doallo)</li>
	<li><a href="http://www.geekride.com/fork-forking-vs-threading-thread-linux-kernel/">fork vs thread</a></li>
	<li>Linux Threads: <a href="http://www.thegeekstuff.com/2012/03/linux-threads-intro/">Intro</a>, <a href="http://www.thegeekstuff.com/2012/04/create-threads-in-linux/">creating</a>, <a href="http://www.thegeekstuff.com/2012/04/terminate-c-thread/">finishing them</a></li>
	<li>Threads: <a href="https://users.cs.cf.ac.uk/Dave.Marshall/C/node29.html#SECTION002900000000000000000">Basics</a>, <a href="https://users.cs.cf.ac.uk/Dave.Marshall/C/node30.html#SECTION003000000000000000000">Avanced</a>, <a href="https://users.cs.cf.ac.uk/Dave.Marshall/C/node31.html#SECTION003100000000000000000">Synchronization</a> y <a href="https://users.cs.cf.ac.uk/Dave.Marshall/C/node32.html#SECTION003200000000000000000">Ejemplos</a></li>
</ul>


</section>
</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
